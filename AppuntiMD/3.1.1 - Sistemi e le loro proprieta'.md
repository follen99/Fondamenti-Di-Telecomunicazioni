# Sistemi nel dominio del tempo

I sistemi nel dominio del tempo sono sistemi che possono essere descritti in base al tempo in cui i loro segnali o input cambiano. Questi sistemi possono essere analizzati e descritti utilizzando le equazioni del tempo che mostrano come i loro segnali di input si traducono in segnali di uscita.

![image-20230204184953429](./assets/image-20230204184953429.png)

Sostanzialmente i sistemi sono delle **black box** che dato un input restituiscono un output.

## Esempi di sistemi

### Esempio di sistema continuo: Partitore Resistivo

![image-20230204185059153](./assets/image-20230204185059153.png)

### Esempio di sistema discreto: Ritardo elementare

![image-20230204185119156](./assets/image-20230204185119156.png)

## Disposizioni di sistemi

### Sistemi connessi in cascata

![image-20230204185243675](./assets/image-20230204185243675.png)

### Sistemi connessi in parallelo

![image-20230204185250049](./assets/image-20230204185250049.png)

### Sistemi connessi in retroazione

![image-20230204185258435](./assets/image-20230204185258435.png)

#### Esempio di sistemi connessi in parallelo: filtro MA - Moving Average

Il filtro MA non fa altro che prendere gli ultimi n input e calcolarne la media; il valore risultante verrà poi trasmesso in output.
L'utilità di questo filtro risiede nel fatto che **smussa** in modo direttamente proporzionale al valore di N; questo vuol dire che **di più elementi è calcolata la media ad ogni iterazione, più smussato sarà l'output risultante.**

![image-20230204190646058](./assets/image-20230204190646058.png)

**Codice matlab per il filtro MA**

```matlab
function filtered_signal = getFilteredSignal(originalSignal, magnitude)
    filtered_signal = zeros(1, length(originalSignal));
    for n = 1:length(originalSignal)
        j = n;
        times = 0;
        sum = 0;

        while (times < magnitude && j > 1)                
            sum = sum + originalSignal(j);
            j = j-1;
            times = times + 1;
        end

        filtered_signal(n) = sum/magnitude;
    end
end
```

Questa funzione riceve in ingresso due parametri:

- Segnale da filtrare
- il numero di elementi di cui fare la media

Il codice si serve di due loop:

- Loop foor
  Questo loop serve ad iterare su tutti gli elementi dell'array, in modo da visitare tutti gli elementi del segnale e calcolarne la media mobile.
  Alla fine di ogni ciclo viene calcolata la media degli ultimi m elementi in input; la media viene posta alla posizione corrente di un nuovo array (segnale filtrato).
- Loop While
  Questo loop serve a calcolare la media degli m elementi (magnitude)

Alla fine delle varie operazioni la funzione restituisce un nuovo segnale filtrato:

![MA_filter](./assets/MA_filter-5537246.png)

> Nella parte iniziale c'è una "rampa" proprio perchè la media deve "accumularsi" fino a cui magnitude = n elementi arrivati in input.
>
> Se ad esempio decidiamo di fare la media di 50 elementi, e ne sono arrivati 20 è ovvio che la media non sarà completa.

## Proprietà dei sistemi

### Proprietà 1 dei sistemi: Sistemi Dispersivi / Sistemi con memoria

Un sistema è dispersivo **o con memoria** nel momento in cui **l'uscita in un istante di tempo dipende anche da valori precedenti del tempo**:

![image-20230204200611982](./assets/image-20230204200611982.png)

> Il filtro MA visto prima ne è un esempio lampante: il segnale in output dipende proprio dalla media degli m valori precedenti all'istante di tempo corrente.

### Proprietà 2 dei sistemi: Sistemi Causali

La definizione di sistema causale è, se vogliamo, molto simile a quella dei sistemi non dispersivi; infatti un sistema causale è un sistema il cui segnale in uscita dipende solo dai valori del segnale in input **dello stesso istante di tempo o al massimo a valori del segnale per istanti di tempo precedenti a quello corrente.**

**--> In un sistema causale l'output non dipende da valori futuri dell'input, rispetto all'istante di tempo corrente.**

![image-20230204201112563](./assets/image-20230204201112563.png)

### Proprietà 3 dei sistemi: Sistemi invertibili

**Un sistema è invartibile se esiste un sistema, detto sistema inverso, che in uscita restituisca l'ingresso del primo sistema.**

![image-20230204201247388](./assets/image-20230204201247388.png)

#### Esempio di sistema non invertibile: elevazione al quadrato

![image-20230204202908577](./assets/image-20230204202908577.png)

#### Esempio di sistema invertibile: Accumulatore ed invertitore

L'accumulatore è un sistema che somma il valore corrente con quelli precedenti; quindi l'elemento n varrà la somma di tutti gli input fino all'input n;

Deduciamo (dopo qualche ragionamento) che il valore di input all'istante n, è uguale alla somma di tutti i valori fino all'istante n, **meno la somma di tutti i valori fino all'istante n-1**, ovvero:

![image-20230204202842304](./assets/image-20230204202842304.png)

Possiamo convincerci di questa cosa andando a riprodurre il tutto su matlab:

```matlab
% funzione che funge da sistema accumulatore
function accumulated_signal = getAccumulatedSignal(starting_signal)
    accumulated_signal = zeros(1, length(starting_signal));

    for n = 1:length(starting_signal)
        acc_value = 0;
        for j = 1:n
            acc_value = acc_value + starting_signal(j);
        end
        accumulated_signal(n) = acc_value;
    end
end

% funzione che funge da sistema inverso: invertitore
function original_signal = getOriginalSignal(accumulated_signal)
    original_signal = zeros(1, length(accumulated_signal));
    original_signal(1) = accumulated_signal(1);
    
    for n = 2:length(accumulated_signal)
        original_signal(n) = accumulated_signal(n) - accumulated_signal(n-1);	% where the magic happens
    end
end
```

Le due funzioni sono molto semplici:

1. La prima funzione (di accumulazione) somma tutti gli elementi fino all'elemento corrente e posiziona la somma nella posizione equivalente alla corrente di un nuovo array.
2. La seconda funzione (di inversione) sottrae all'elemento corrente la somma degli elementi dell'elemento precedente:
   `original_signal(n) = accumulated_signal(n) - accumulated_signal(n-1);`.

Otteniamo quindi il seguente output:

![accumulatore_e_invertitore](./assets/accumulatore_e_invertitore.png)



### Proprietà 4 dei sistemi: Invarianza temporale

Un sistema è **invariante temporalmente** se ad una traslazione dell'ingresso corrisponde la stessa traslazione nel tempo dell'uscita.

Questo vuol dire che per controllare di trovarci con un sistema temporalmente invariante ci basta fornire al sistema un segnale ritardato di T<sub>0</sub> ed osservare il segnale in output: se il segnale in output è ritardato di T<sub>0</sub> allora il sistema è temporalmente invariante:

![image-20230205110111788](./assets/image-20230205110111788.png)

### Proprietà 5 dei sistemi: Stabilità

Un sistema è stabile se la sua uscita (risposta) non cresce all'infinito a seguito di un'entrata (stimolo) limitato. In altre parole, se la risposta a un segnale limitato non diventa eccessivamente grande o piccola nel tempo, il sistema è stabile.

![image-20230205110417299](./assets/image-20230205110417299.png)

Per convincerci che un sistema sia o meno stabile, ci basta effettuare il limite per il tempo che tende all'infinito dell'output considerando un input limitato; in questo caso scegliamo come input il gradino unitario che sappiamo avere valori limitati anche per valori _infiniti_ di tempo:

![image-20230205110559110](./assets/image-20230205110559110.png)

### Proprietà 6 dei sistemi: Linearità

Un sistema è lineare quando la sua risposta ad una combinazione di segnali in ingresso è uguale alla combinazione delle sue risposte ai singoli segnali di ingresso. 

Dal punto di vista "fiscale" un sistema è detto lineare nel momento in cui esso è sia **omogeneo che additivo**:

#### Proprietà 6.1 dei sistemi: Omogeneità

Un sistema è omogeneo nel momento in cui applichiamo un cambiamento di scala in input e questo si ripresenta anche in output:

![image-20230205112239139](./assets/image-20230205112239139.png)

#### Proprietà 6.2 dei sistemi: Additività

Un sistema è additivo quando in input viene fornito un segnale composto dalla somma di due (o più segnali) ed in output il sistema restituirà la somma degli output:

![image-20230205112359760](./assets/image-20230205112359760.png)

---

Capiamo bene che un sistema è lineare nel momento in cui c'è una **combinazione di queste due proprietà:**

![image-20230205112436778](./assets/image-20230205112436778.png)

#### Esempio di sistema lineare

Abbiamo visto come un sistema lineare debba rispettare la proprietà:

> Dato un input composto dalla somma di due (o più) segnali, l'output deve essere la somma degli output; se nel sistema c'è una moltiplicazione del segnale per una costante, questa deve ripercuotersi su ogni "sottosegnale".

Possiamo convincerci di ciò grazie a del buon codice matlab:

```matlab
function y = linear_system(x, a)
% LINEAR_SYSTEM modifica un segnale di ingresso in modo lineare
% x: segnale di ingresso
% a: fattore di scala
% y: segnale di uscita

y = a .* x;
end
```

Questa funzione semplicemente moltiplica ogni elemento di un segnale in input per una costante; possiamo fornire alla funzione sia un segnale elementare che un segnale ottenuto dalla somma di due (o più) segnali elementari; infatti è proprio quello che faremo per dimostrare la linearità di questo sistema:

1. Forniamo al sistema un input composto **dalla somma di due segnali elementari** (due finestre diverse) in modo da ottenere 
   y(t) = sys(w1 + w2)
2. Osserviamo l'output del sistema.



1. Forniamo al sistema un input composto da un segnale elementare (una finestra);
2. Successivamente effettueremo la somma di due output del sistema, in modo da ottenere:
   y(t) = sys(w1) + sys(w2)
3. Osserviamo l'output del sistema.

Noteremo che i due output sono identici!

![linearity_property](./assets/linearity_property.png)

#### Esempio di sistema non lineare

Un esempio di sistema non lineare può essere l'elevazione a potenza:

![image-20230205115720186](./assets/image-20230205115720186.png)

```matlab
function y = nonlinear_system(x, power)
% NONLINEAR_SYSTEM modifica un segnale di ingresso in modo non lineare
% x: segnale di ingresso
% y: segnale di uscita

y = x.^power;
end
```

Questa funzione non fa altro che elevare ogni elemento di un segnale alla potenza specificata dall'argomento power; per dimostrare la non linearità del sistema andremo ad effettuare due plot:

1. L'output del sistema moltiplicato per 3.
   `input -> sys -> y(n) * 3`
2. Fornisco un input moltiplicato per 3 al sistema e poi lo lotto.
   `input * 3 -> sys -> y(n)`

![non_linear_property](./assets/non_linear_property-5594970.png)

Come possiamo osservare (asse y) i due segnali sono diversi;
